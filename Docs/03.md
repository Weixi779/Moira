# NetworkKit æ’ä»¶ç³»ç»Ÿ

## æ¦‚è¿°

NetworkKit é‡‡ç”¨åˆ†ç¦»å¼æ’ä»¶è®¾è®¡ï¼Œå°†æ’ä»¶åˆ†ä¸ºå››ç§ç±»å‹ï¼Œæ¯ç§ç±»å‹æœ‰æ˜ç¡®çš„èŒè´£ï¼š

| ç±»å‹ | èŒè´£ | æ‰§è¡Œæ–¹å¼ |
|------|------|----------|
| `TransformPlugin` | ä¿®æ”¹è¯·æ±‚/å“åº” | ä¸²è¡Œï¼Œå¯æŠ›é”™ |
| `ObserverPlugin` | è§‚å¯Ÿç”Ÿå‘½å‘¨æœŸäº‹ä»¶ | **å¹¶è¡Œ**ï¼Œæ— è¿”å›å€¼ |
| `ProgressPlugin` | ç›‘æ§ä¸Šä¼ /ä¸‹è½½è¿›åº¦ | åŒæ­¥å›è°ƒ |
| `RetryPlugin` | æ§åˆ¶é‡è¯•ç­–ç•¥ | ä¸²è¡Œï¼Œè¿”å›å†³ç­– |

```
è¯·æ±‚ç”Ÿå‘½å‘¨æœŸï¼š

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    TransformPlugin                       â”‚
    â”‚  prepare() â”€â”€â–º adapt() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º process()     â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚              â”‚                         â”‚
           â–¼              â–¼                         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  APIRequest â”‚  â”‚URLRequestâ”‚              â”‚APIResponseâ”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                         â”‚                          â”‚
                         â”‚  ObserverPlugin          â”‚
                         â”‚  willSend() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º didReceive()
                         â”‚                          â”‚
                         â–¼                          â”‚
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
                   â”‚  Network â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚  Client  â”‚
                   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                        â”‚
                   ProgressPlugin
                   uploadProgress()
                   downloadProgress()
```

---

## TransformPlugin

**ç”¨é€”**ï¼šä¿®æ”¹è¯·æ±‚æˆ–å“åº”å†…å®¹ã€‚

```swift
public protocol TransformPlugin: PluginType {
    /// å‡†å¤‡é˜¶æ®µï¼šä¿®æ”¹ APIRequest
    func prepare(_ target: any APIRequest) async throws -> any APIRequest
    
    /// é€‚é…é˜¶æ®µï¼šä¿®æ”¹ URLRequestï¼ˆå¦‚æ·»åŠ  Headerï¼‰
    func adapt(_ request: URLRequest, context: RequestContext) async throws -> URLRequest
    
    /// å¤„ç†é˜¶æ®µï¼šä¿®æ”¹å“åº”
    func process(_ response: APIResponse, context: RequestContext) async throws -> APIResponse
}
```

### ç¤ºä¾‹ï¼šè®¤è¯æ’ä»¶

```swift
final class AuthPlugin: TransformPlugin {
    private let tokenProvider: () async -> String?
    
    init(tokenProvider: @escaping () async -> String?) {
        self.tokenProvider = tokenProvider
    }
    
    func adapt(_ request: URLRequest, context: RequestContext) async throws -> URLRequest {
        var request = request
        if let token = await tokenProvider() {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        return request
    }
}

// ä½¿ç”¨
let provider = NetworkProvider(
    plugins: [
        AuthPlugin { await TokenManager.shared.accessToken }
    ]
)
```

### ç¤ºä¾‹ï¼šè¯·æ±‚ç­¾åæ’ä»¶

```swift
final class SignaturePlugin: TransformPlugin {
    private let secret: String
    
    init(secret: String) {
        self.secret = secret
    }
    
    func adapt(_ request: URLRequest, context: RequestContext) async throws -> URLRequest {
        var request = request
        
        let timestamp = String(Int(Date().timeIntervalSince1970))
        let signature = generateSignature(
            path: request.url?.path ?? "",
            timestamp: timestamp,
            secret: secret
        )
        
        request.setValue(timestamp, forHTTPHeaderField: "X-Timestamp")
        request.setValue(signature, forHTTPHeaderField: "X-Signature")
        
        return request
    }
    
    private func generateSignature(path: String, timestamp: String, secret: String) -> String {
        // HMAC-SHA256 ç­¾åå®ç°
        // ...
    }
}
```

---

## ObserverPlugin

**ç”¨é€”**ï¼šè§‚å¯Ÿè¯·æ±‚ç”Ÿå‘½å‘¨æœŸï¼Œä¸ä¿®æ”¹è¯·æ±‚/å“åº”ã€‚

```swift
public protocol ObserverPlugin: PluginType {
    /// è¯·æ±‚å‘é€å
    func willSend(context: RequestContext) async
    
    /// å“åº”æ¥æ”¶å
    func didReceive(context: RequestContext) async
}
```

### ç¤ºä¾‹ï¼šæ—¥å¿—æ’ä»¶

```swift
final class LoggingPlugin: ObserverPlugin {
    func willSend(context: RequestContext) async {
        let target = context.target
        print("ğŸ“¤ [\(target.method.rawValue)] \(target.path)")
    }
    
    func didReceive(context: RequestContext) async {
        if let response = await context.response {
            let duration = await context.snapshot().duration
            print("ğŸ“¥ [\(response.statusCode)] \(duration)ms")
        } else if let error = await context.error {
            print("âŒ Error: \(error.localizedDescription)")
        }
    }
}
```

### ç¤ºä¾‹ï¼šåŸ‹ç‚¹æ’ä»¶

```swift
final class AnalyticsPlugin: ObserverPlugin {
    private let tracker: AnalyticsTracker
    
    func didReceive(context: RequestContext) async {
        let snapshot = await context.snapshot()
        
        tracker.track("api_request", properties: [
            "path": snapshot.target.path,
            "status": snapshot.response?.statusCode ?? -1,
            "duration": snapshot.duration,
            "retry_count": snapshot.retryCount,
            "success": snapshot.error == nil
        ])
    }
}
```

---

## ProgressPlugin

**ç”¨é€”**ï¼šç›‘æ§ä¸Šä¼ /ä¸‹è½½è¿›åº¦ã€‚

> âš ï¸ æ–¹æ³•æ˜¯**åŒæ­¥**çš„ï¼Œå› ä¸ºè¿›åº¦å›è°ƒéå¸¸é¢‘ç¹ã€‚å¦‚éœ€å¼‚æ­¥æ“ä½œï¼Œåœ¨æ–¹æ³•å†…éƒ¨åˆ›å»º Taskã€‚

```swift
public protocol ProgressPlugin: PluginType {
    /// ä¸Šä¼ è¿›åº¦
    func uploadProgress(_ progress: NetworkProgress, snapshot: RequestContext.Snapshot)
    
    /// ä¸‹è½½è¿›åº¦
    func downloadProgress(_ progress: NetworkProgress, snapshot: RequestContext.Snapshot)
}

public struct NetworkProgress: Sendable {
    public let completedBytes: Int64
    public let totalBytes: Int64?
    public var fractionCompleted: Double  // 0.0 ~ 1.0
}
```

### ç¤ºä¾‹ï¼šè¿›åº¦ UI æ›´æ–°

```swift
@MainActor
final class UploadProgressPlugin: ProgressPlugin, @unchecked Sendable {
    private let onProgress: (Double) -> Void
    
    init(onProgress: @escaping (Double) -> Void) {
        self.onProgress = onProgress
    }
    
    nonisolated func uploadProgress(_ progress: NetworkProgress, snapshot: RequestContext.Snapshot) {
        let fraction = progress.fractionCompleted
        Task { @MainActor in
            self.onProgress(fraction)
        }
    }
}

// ä½¿ç”¨
let progressPlugin = UploadProgressPlugin { fraction in
    uploadProgressView.progress = fraction
}

let provider = NetworkProvider(plugins: [progressPlugin])
try await provider.request(.upload(file: fileData))
```

---

## RetryPlugin

**ç”¨é€”**ï¼šæ§åˆ¶å¤±è´¥è¯·æ±‚çš„é‡è¯•ç­–ç•¥ã€‚

> âœ… é‡è¯•é€»è¾‘ç”± NetworkProvider ä½¿ç”¨é€’å½’æ‰§è¡Œã€‚æ¯æ¬¡é‡è¯•éƒ½ä¼šé‡æ–°èµ°å®Œæ•´çš„æ’ä»¶æµç¨‹ï¼ˆprepare â†’ adapt â†’ executeï¼‰ï¼Œä½¿ Token åˆ·æ–°ç­‰ä¿®æ”¹èƒ½å¤Ÿç”Ÿæ•ˆã€‚

```swift
public enum RetryDecision: Sendable {
    case doNotRetry
    case retry
    case retryAfter(TimeInterval)
}

public protocol RetryPlugin: PluginType {
    /// å†³å®šæ˜¯å¦é‡è¯•
    func shouldRetry(dueTo error: NetworkError, context: RequestContext) async -> RetryDecision
    
    /// é‡è¯•å‰é€šçŸ¥
    func willRetry(context: RequestContext) async
}
```

### ç¤ºä¾‹ï¼šç½‘ç»œé”™è¯¯é‡è¯•

```swift
final class NetworkRetryPlugin: RetryPlugin {
    private let maxRetries: Int
    private let retryableErrors: Set<URLError.Code>
    
    init(maxRetries: Int = 3) {
        self.maxRetries = maxRetries
        self.retryableErrors = [
            .timedOut,
            .networkConnectionLost,
            .notConnectedToInternet
        ]
    }
    
    func shouldRetry(dueTo error: NetworkError, context: RequestContext) async -> RetryDecision {
        let retryCount = await context.retryCount
        
        guard retryCount < maxRetries else {
            return .doNotRetry
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºå¯é‡è¯•çš„ç½‘ç»œé”™è¯¯
        if case .underlying(let underlying, _) = error,
           let urlError = underlying as? URLError,
           retryableErrors.contains(urlError.code) {
            let delay = pow(2.0, Double(retryCount)) // æŒ‡æ•°é€€é¿
            return .retryAfter(delay)
        }
        
        return .doNotRetry
    }
    
    func willRetry(context: RequestContext) async {
        let count = await context.retryCount
        print("ğŸ”„ Retrying... attempt \(count + 1)")
    }
}
```

### ç¤ºä¾‹ï¼šToken åˆ·æ–°é‡è¯•

```swift
final class TokenRefreshPlugin: RetryPlugin {
    private let tokenManager: TokenManager
    
    func shouldRetry(dueTo error: NetworkError, context: RequestContext) async -> RetryDecision {
        // åªé‡è¯•ä¸€æ¬¡
        guard await context.retryCount == 0 else {
            return .doNotRetry
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸º 401
        guard let response = error.response, response.statusCode == 401 else {
            return .doNotRetry
        }
        
        // å°è¯•åˆ·æ–° Token
        do {
            try await tokenManager.refreshToken()
            return .retry
        } catch {
            return .doNotRetry
        }
    }
}
```

---

## ç»„åˆä½¿ç”¨

ä¸€ä¸ªæ’ä»¶å¯ä»¥åŒæ—¶å®ç°å¤šä¸ªåè®®ï¼š

```swift
final class FullPlugin: TransformPlugin, ObserverPlugin, ProgressPlugin, RetryPlugin {
    // TransformPlugin
    func adapt(_ request: URLRequest, context: RequestContext) async throws -> URLRequest {
        // æ·»åŠ  Header
    }
    
    // ObserverPlugin
    func didReceive(context: RequestContext) async {
        // è®°å½•æ—¥å¿—
    }
    
    // ProgressPlugin
    func uploadProgress(_ progress: NetworkProgress, snapshot: RequestContext.Snapshot) {
        // æ›´æ–° UI
    }
    
    // RetryPlugin
    func shouldRetry(dueTo error: NetworkError, context: RequestContext) async -> RetryDecision {
        // å†³å®šæ˜¯å¦é‡è¯•
    }
}
```

---

## PluginRunner

`PluginRunner` æ˜¯æ’ä»¶çš„æ‰§è¡Œå™¨ï¼Œåœ¨ `NetworkProvider` åˆå§‹åŒ–æ—¶åˆ›å»ºä¸€æ¬¡ï¼Œå¤ç”¨äºæ‰€æœ‰è¯·æ±‚ã€‚

```swift
public struct PluginRunner: Sendable {
    public init(plugins: [any PluginType])
    
    // æŒ‰ç±»å‹åˆ†ç±»åçš„ä¾¿æ·å±æ€§
    public var hasRetryPlugins: Bool
    public var hasProgressPlugins: Bool
}
```

### æ‰§è¡Œç­–ç•¥

| æ’ä»¶ç±»å‹ | æ‰§è¡Œæ–¹å¼ | åŸå›  |
|---------|---------|------|
| Transform | ä¸²è¡Œ | æ’ä»¶é—´æœ‰æ•°æ®ä¾èµ– |
| Observer | **å¹¶è¡Œ** | æ— ä¾èµ–ï¼Œæå‡æ€§èƒ½ |
| Retry | ä¸²è¡Œ | ç¬¬ä¸€ä¸ªé doNotRetry å†³ç­–ç”Ÿæ•ˆ |
| Progress | ä¸²è¡Œï¼ˆåŒæ­¥ï¼‰ | å¿«é€Ÿã€é¢‘ç¹çš„å›è°ƒ |

```swift
let provider = NetworkProvider(
    plugins: [
        LoggingPlugin(),    // Observerï¼šä¸å…¶ä»– Observer å¹¶è¡Œæ‰§è¡Œ
        AuthPlugin(),       // Transformï¼šæŒ‰é¡ºåºæ‰§è¡Œ
        RetryPlugin()       // Retryï¼šæŒ‰é¡ºåºæ‰§è¡Œ
    ]
)
```
