# NetworkKit Mock 与测试

## 概述

NetworkKit 提供两种测试方式：

1. **MockBehavior** - Provider 级别，返回 `mockResponse` 数据
2. **MockNetworkClient** - Client 级别，完全控制网络层

```
┌─────────────────────────────────────────────────────────┐
│                    NetworkProvider                       │
│                                                          │
│   MockBehavior = .immediate                              │
│   ┌─────────────────────────────────────────────────┐   │
│   │  跳过插件，直接返回 target.mockResponse          │   │
│   └─────────────────────────────────────────────────┘   │
│                                                          │
│   MockBehavior = .never (默认)                           │
│   ┌─────────────────────────────────────────────────┐   │
│   │  正常流程 → Plugins → NetworkClient              │   │
│   └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

---

## MockBehavior

控制 Provider 如何处理请求。

```swift
public enum MockBehavior: Sendable {
    /// 正常网络请求（默认）
    case never
    
    /// 立即返回 mockResponse
    case immediate
    
    /// 延迟后返回 mockResponse
    case delayed(TimeInterval)
}
```

### 使用方式

```swift
// 1. 定义 API 时提供 mockResponse
enum UserAPI: APIRequest {
    case getUser(id: String)
    
    var mockResponse: MockResponse {
        switch self {
        case .getUser(let id):
            let json = """
            {"id": "\(id)", "name": "Mock User", "email": "mock@test.com"}
            """
            return .sample(json.data(using: .utf8)!)
        }
    }
}

// 2. 创建 Mock Provider
let mockProvider = NetworkProvider(
    mockBehavior: .immediate  // 立即返回 mockResponse
)

// 3. 请求会返回 mock 数据
let response = try await mockProvider.request(.getUser(id: "123"))
// response.data 包含 mock JSON
```

### 模拟延迟

```swift
// 模拟 0.5 秒网络延迟
let provider = NetworkProvider(
    mockBehavior: .delayed(0.5)
)
```

### 模拟错误

```swift
enum UserAPI: APIRequest {
    case getUser(id: String)
    
    var mockResponse: MockResponse {
        switch self {
        case .getUser(let id):
            if id == "error" {
                // 模拟网络错误
                return .failure(URLError(.notConnectedToInternet))
            }
            return .sample(mockData)
        }
    }
}
```

---

## MockResponse

Mock 响应的定义。

```swift
public enum MockResponse {
    /// 成功响应
    case success(statusCode: Int, data: Data)
    
    /// 网络错误
    case failure(Error)
}

extension MockResponse {
    /// 便捷方法：创建 200 成功响应
    public static func sample(_ data: Data, statusCode: Int = 200) -> MockResponse
}
```

### 示例

```swift
// 成功响应
.sample(jsonData)
.sample(jsonData, statusCode: 201)
.success(statusCode: 204, data: Data())

// 错误响应
.failure(URLError(.timedOut))
.failure(URLError(.notConnectedToInternet))
```

---

## 根据参数动态生成 Mock

`mockResponse` 是计算属性，可以根据请求参数动态返回不同的 mock 数据：

```swift
enum BookAPI: APIRequest {
    case list(page: Int)
    case detail(id: String)
    
    var mockResponse: MockResponse {
        switch self {
        case .list(let page):
            // 根据页码返回不同数据
            if page > 10 {
                return .sample("[]".data(using: .utf8)!)  // 空列表
            }
            return .sample(generateBookListJSON(page: page))
            
        case .detail(let id):
            if id == "not_found" {
                return .success(statusCode: 404, data: Data())
            }
            return .sample(generateBookDetailJSON(id: id))
        }
    }
}
```

---

## 单元测试示例

### 测试 Service 层

```swift
import Testing
@testable import YourApp

struct UserServiceTests {
    
    @Test
    func testGetUser() async throws {
        // Given
        let mockProvider = NetworkProvider(mockBehavior: .immediate)
        let service = UserService(provider: mockProvider)
        
        // When
        let user = try await service.getUser(id: "123")
        
        // Then
        #expect(user.id == "123")
        #expect(user.name == "Mock User")
    }
    
    @Test
    func testGetUserNetworkError() async throws {
        // Given - mockResponse 返回 .failure
        let mockProvider = NetworkProvider(mockBehavior: .immediate)
        let service = UserService(provider: mockProvider)
        
        // When/Then
        await #expect(throws: NetworkError.self) {
            try await service.getUser(id: "error")
        }
    }
}
```

### 测试插件

```swift
struct AuthPluginTests {
    
    @Test
    func testAddsAuthHeader() async throws {
        // Given
        let plugin = AuthPlugin { "test-token" }
        var request = URLRequest(url: URL(string: "https://api.test.com")!)
        let context = RequestContext(target: TestAPI.sample)
        
        // When
        let adapted = try await plugin.adapt(request, context: context)
        
        // Then
        #expect(adapted.value(forHTTPHeaderField: "Authorization") == "Bearer test-token")
    }
}
```

---

## MockNetworkClient

完全控制网络层，适用于更复杂的测试场景。

```swift
final class MockNetworkClient: NetworkClient, @unchecked Sendable {
    var mockResult: Result<(Data, HTTPURLResponse), Error> = .success((Data(), HTTPURLResponse()))
    var requestCount = 0
    var lastRequest: URLRequest?
    
    func request(_ request: URLRequest) async throws -> (Data, HTTPURLResponse) {
        requestCount += 1
        lastRequest = request
        return try mockResult.get()
    }
    
    func upload(_ request: URLRequest, data: Data, progress: (@Sendable (NetworkProgress) -> Void)?) async throws -> (Data, HTTPURLResponse) {
        requestCount += 1
        lastRequest = request
        // 模拟进度
        progress?(NetworkProgress(completedBytes: 50, totalBytes: 100))
        progress?(NetworkProgress(completedBytes: 100, totalBytes: 100))
        return try mockResult.get()
    }
    
    // ... 其他 upload 方法
}
```

### 使用 MockNetworkClient

```swift
@Test
func testPluginCalledBeforeNetwork() async throws {
    // Given
    let mockClient = MockNetworkClient()
    let trackingPlugin = TrackingPlugin()
    
    let provider = NetworkProvider(
        client: mockClient,
        plugins: [trackingPlugin]
    )
    
    // When
    _ = try await provider.request(.sample)
    
    // Then
    #expect(trackingPlugin.willSendCalled)
    #expect(trackingPlugin.didReceiveCalled)
    #expect(mockClient.requestCount == 1)
}
```

---

## DI 集成

在 DI 容器中配置不同环境的 Provider：

```swift
// AppContainer.swift
final class AppContainer {
    
    static let shared = AppContainer()
    
    private let isTestEnvironment: Bool
    
    init(isTestEnvironment: Bool = false) {
        self.isTestEnvironment = isTestEnvironment
    }
    
    // MARK: - Network Providers
    
    var userProvider: NetworkProvider {
        NetworkProvider(
            plugins: commonPlugins,
            mockBehavior: isTestEnvironment ? .immediate : .never
        )
    }
    
    private var commonPlugins: [any PluginType] {
        [
            AuthPlugin { await TokenManager.shared.accessToken },
            LoggingPlugin()
        ]
    }
}

// 测试中
let testContainer = AppContainer(isTestEnvironment: true)
let service = UserService(provider: testContainer.userProvider)
```

---

## 最佳实践

1. **Mock 数据放在 API 定义中** - `mockResponse` 与 API 定义在一起，便于维护

2. **使用 `MockBehavior.delayed`** - 模拟真实网络延迟，发现 UI 问题

3. **测试边界情况** - 使用 mock 测试 404、500、超时等场景

4. **插件单独测试** - 插件逻辑与网络分离，单独测试更容易

5. **保持 mock 数据真实** - Mock 数据结构应与真实 API 一致
